# OneTimeMail フロントエンド設計書

## 1. 概要

### 1.1 目的
OneTimeMailプロジェクトのフロントエンド設計を定義する。

### 1.2 技術スタック
- **フレームワーク**: Next.js 14
- **言語**: TypeScript
- **スタイリング**: Tailwind CSS
- **状態管理**: React Hooks
- **API通信**: Next.js Server Actions

## 2. プロジェクト構造

### 2.1 ディレクトリ構成
```
src/
├── app/
│   ├── page.tsx              # メイン画面
│   ├── layout.tsx            # レイアウト
│   ├── globals.css           # グローバルスタイル
│   └── loading.tsx           # ローディング画面
├── components/
│   ├── EmailGenerator.tsx    # メールアドレス生成
│   ├── EmailList.tsx         # メール一覧
│   ├── EmailViewer.tsx       # メール詳細
│   ├── CopyButton.tsx        # コピーボタン
│   ├── LoadingSpinner.tsx    # ローディングスピナー
│   └── ErrorMessage.tsx      # エラーメッセージ
├── hooks/
│   ├── useEmailAddress.ts    # メールアドレス管理
│   ├── useEmailList.ts       # メール一覧管理
│   └── useS3Checker.ts       # S3メールチェック
├── utils/
│   ├── amplify-utils.ts      # Amplify設定・ユーティリティ
│   └── emailGenerator.ts     # メールアドレス生成
└── types/
    └── index.ts              # 型定義
```

## 3. 型定義

### 3.1 基本型定義
```typescript
// types/index.ts
export interface EmailAddress {
  id: string;
  address: string;
  createdAt: string;
  isActive: boolean;
}

export interface Email {
  id: string;
  from: string;
  subject?: string;
  body: string;
  receivedAt: string;
  s3Key: string;
}

export interface S3Object {
  Key: string;
  LastModified: Date;
  Size: number;
}

export interface ApiError {
  code: string;
  message: string;
  details?: any;
}
```

## 4. コンポーネント設計

### 4.1 メイン画面（page.tsx）
```typescript
'use client';

import { useEffect, useState } from 'react';
import { EmailGenerator } from '@/components/EmailGenerator';
import { EmailList } from '@/components/EmailList';
import { useEmailAddress } from '@/hooks/useEmailAddress';
import { useEmailList } from '@/hooks/useEmailList';
import { useS3Checker } from '@/hooks/useS3Checker';

export default function HomePage() {
  const { emailAddress, generateEmailAddress, loading: addressLoading } = useEmailAddress();
  const { emails, refreshEmails, loading: emailsLoading } = useEmailList();
  const { startChecking, stopChecking } = useS3Checker();

  // ページ読み込み時にメールアドレス生成
  useEffect(() => {
    generateEmailAddress();
  }, []);

  // メールアドレスが生成されたらS3チェック開始
  useEffect(() => {
    if (emailAddress?.address) {
      startChecking(emailAddress.address, refreshEmails);
    }
    
    return () => {
      stopChecking();
    };
  }, [emailAddress?.address]);

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold text-center mb-8">
          一時メールアドレス
        </h1>
        
        <div className="max-w-4xl mx-auto space-y-8">
          <EmailGenerator 
            emailAddress={emailAddress} 
            loading={addressLoading}
          />
          
          <EmailList 
            emails={emails} 
            loading={emailsLoading}
          />
        </div>
      </div>
    </div>
  );
}
```

### 4.2 メールアドレス生成コンポーネント
```typescript
// components/EmailGenerator.tsx
'use client';

import { useState } from 'react';
import { CopyButton } from './CopyButton';
import { LoadingSpinner } from './LoadingSpinner';
import { EmailAddress } from '@/types';

interface EmailGeneratorProps {
  emailAddress: EmailAddress | null;
  loading: boolean;
}

export function EmailGenerator({ emailAddress, loading }: EmailGeneratorProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    if (emailAddress?.address) {
      try {
        await navigator.clipboard.writeText(emailAddress.address);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      } catch (error) {
        console.error('Failed to copy:', error);
      }
    }
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">一時メールアドレス</h2>
        <div className="flex items-center justify-center py-8">
          <LoadingSpinner />
          <span className="ml-2">生成中...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-4">一時メールアドレス</h2>
      
      {emailAddress ? (
        <div className="space-y-4">
          <div className="flex items-center space-x-2">
            <input
              type="text"
              value={emailAddress.address}
              readOnly
              className="flex-1 px-3 py-2 border border-gray-300 rounded-md bg-gray-50 text-sm font-mono"
            />
            <CopyButton 
              onCopy={handleCopy}
              copied={copied}
            />
          </div>
          
          <div className="text-sm text-gray-600">
            <p>作成日時: {new Date(emailAddress.createdAt).toLocaleString()}</p>
            <p className="text-xs text-gray-500 mt-1">
              このアドレスは画面を閉じると使用できなくなります
            </p>
          </div>
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500">
          メールアドレスの生成に失敗しました
        </div>
      )}
    </div>
  );
}
```

### 4.3 メール一覧コンポーネント
```typescript
// components/EmailList.tsx
'use client';

import { useState } from 'react';
import { EmailViewer } from './EmailViewer';
import { LoadingSpinner } from './LoadingSpinner';
import { Email } from '@/types';

interface EmailListProps {
  emails: Email[];
  loading: boolean;
}

export function EmailList({ emails, loading }: EmailListProps) {
  const [selectedEmail, setSelectedEmail] = useState<Email | null>(null);

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">受信メール</h2>
        <div className="flex items-center justify-center py-8">
          <LoadingSpinner />
          <span className="ml-2">読み込み中...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-4">
        受信メール ({emails.length}件)
      </h2>
      
      {emails.length === 0 ? (
        <div className="text-center py-8 text-gray-500">
          受信メールはありません
        </div>
      ) : (
        <div className="space-y-2">
          {emails.map((email) => (
            <div
              key={email.id}
              className="p-4 border rounded-lg cursor-pointer transition-colors hover:bg-gray-50"
              onClick={() => setSelectedEmail(email)}
            >
              <div className="flex items-start justify-between">
                <div className="flex-1 min-w-0">
                  <div className="font-medium text-sm truncate">
                    {email.from}
                  </div>
                  <div className="text-sm text-gray-600 truncate mt-1">
                    {email.subject || '(件名なし)'}
                  </div>
                </div>
                <div className="text-xs text-gray-500 ml-2">
                  {new Date(email.receivedAt).toLocaleTimeString()}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
      
      {selectedEmail && (
        <EmailViewer
          email={selectedEmail}
          onClose={() => setSelectedEmail(null)}
        />
      )}
    </div>
  );
}
```

### 4.4 メール詳細コンポーネント
```typescript
// components/EmailViewer.tsx
'use client';

import { Email } from '@/types';

interface EmailViewerProps {
  email: Email;
  onClose: () => void;
}

export function EmailViewer({ email, onClose }: EmailViewerProps) {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden">
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="text-lg font-semibold">メール詳細</h3>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            ✕
          </button>
        </div>
        
        <div className="p-4 overflow-y-auto max-h-[60vh]">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">
                送信者
              </label>
              <p className="mt-1 text-sm text-gray-900">{email.from}</p>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700">
                件名
              </label>
              <p className="mt-1 text-sm text-gray-900">
                {email.subject || '(件名なし)'}
              </p>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700">
                受信日時
              </label>
              <p className="mt-1 text-sm text-gray-900">
                {new Date(email.receivedAt).toLocaleString()}
              </p>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700">
                本文
              </label>
              <div className="mt-1 p-3 bg-gray-50 rounded-md">
                <pre className="text-sm text-gray-900 whitespace-pre-wrap">
                  {email.body}
                </pre>
              </div>
            </div>
          </div>
        </div>
        
        <div className="flex items-center justify-end p-4 border-t bg-gray-50">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600"
          >
            閉じる
          </button>
        </div>
      </div>
    </div>
  );
}
```

### 4.5 コピーボタンコンポーネント
```typescript
// components/CopyButton.tsx
'use client';

interface CopyButtonProps {
  onCopy: () => void;
  copied: boolean;
}

export function CopyButton({ onCopy, copied }: CopyButtonProps) {
  return (
    <button
      onClick={onCopy}
      className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
        copied
          ? 'bg-green-500 text-white'
          : 'bg-blue-500 text-white hover:bg-blue-600'
      }`}
    >
      {copied ? '✓ コピー完了' : 'コピー'}
    </button>
  );
}
```

## 5. カスタムフック設計

### 5.1 メールアドレス管理フック
```typescript
// hooks/useEmailAddress.ts
'use client';

import { useState, useCallback } from 'react';
import { EmailAddress } from '@/types';
import { createEmailAddress } from '@/app/actions/email-actions';

export function useEmailAddress() {
  const [emailAddress, setEmailAddress] = useState<EmailAddress | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const generateEmailAddress = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await createEmailAddress();
      if (result.success && result.data) {
        setEmailAddress(result.data);
      } else {
        setError(result.error || 'Failed to generate email address');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      console.error('Failed to generate email address:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    emailAddress,
    loading,
    error,
    generateEmailAddress
  };
}
```

### 5.2 メール一覧管理フック
```typescript
// hooks/useEmailList.ts
'use client';

import { useState, useCallback } from 'react';
import { Email } from '@/types';

export function useEmailList() {
  const [emails, setEmails] = useState<Email[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const refreshEmails = useCallback(async (newEmails: Email[]) => {
    setLoading(true);
    setError(null);
    
    try {
      setEmails(newEmails);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      console.error('Failed to refresh emails:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    emails,
    loading,
    error,
    refreshEmails
  };
}
```

### 5.3 S3チェックフック
```typescript
// hooks/useS3Checker.ts
'use client';

import { useRef, useCallback } from 'react';
import { checkS3Emails } from '@/app/actions/email-actions';
import { Email } from '@/types';

export function useS3Checker() {
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const startChecking = useCallback(async (
    emailAddress: string, 
    onEmailsUpdate: (emails: Email[]) => void
  ) => {
    // 即座にチェック
    const result = await checkS3Emails(emailAddress);
    if (result.success && result.data) {
      onEmailsUpdate(result.data);
    }

    // 30秒間隔でチェック
    intervalRef.current = setInterval(async () => {
      try {
        const result = await checkS3Emails(emailAddress);
        if (result.success && result.data) {
          onEmailsUpdate(result.data);
        }
      } catch (error) {
        console.error('Failed to check S3 emails:', error);
      }
    }, 30000);
  }, []);

  const stopChecking = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  return {
    startChecking,
    stopChecking
  };
}
```

## 6. Server Actions実装

### 6.1 メールアドレス生成Server Action
```typescript
// app/actions/email-actions.ts
"use server";

import { generateClient } from 'aws-amplify/data';
import type { Schema } from '@/amplify/data/resource';
import { list, getUrl } from 'aws-amplify/storage';
import { Email } from '@/types';

const client = generateClient<Schema>();

export async function createEmailAddress(): Promise<{
  success: boolean;
  data?: { id: string; address: string };
  error?: string;
}> {
  try {
    // ランダムメールアドレス生成
    const address = generateEmailAddress();
    
    // 重複チェック
    const exists = await checkEmailAddressExists(address);
    if (exists) {
      return {
        success: false,
        error: 'Email address already exists'
      };
    }

    // メールアドレス作成
    const { data, errors } = await client.models.EmailAddress.create({
      address,
      createdAt: Date.now(),
      isActive: true
    });

    if (errors) {
      return {
        success: false,
        error: 'Failed to create email address'
      };
    }

    return {
      success: true,
      data: {
        id: data.id,
        address: data.address
      }
    };
  } catch (error) {
    return {
      success: false,
      error: 'Internal server error'
    };
  }
}

export async function checkS3Emails(emailAddress: string): Promise<{
  success: boolean;
  data?: Email[];
  error?: string;
}> {
  try {
    // S3バケットからメールファイルをリスト
    const listResult = await list({
      prefix: 'email/',
      options: {
        bucketName: 'otm-mec-mejsh-com-recieve'
      }
    });
    
    const emails: Email[] = [];
    
    if (listResult.items) {
      for (const item of listResult.items) {
        if (item.key) {
          try {
            // メールファイルのURLを取得
            const url = await getUrl({
              key: item.key,
              options: {
                bucketName: 'otm-mec-mejsh-com-recieve'
              }
            });
            
            // メールファイルを取得
            const response = await fetch(url.url);
            const emailContent = await response.text();
            
            if (isEmailForAddress(emailContent, emailAddress)) {
              const email = parseEmailContent(emailContent, item.key);
              emails.push(email);
            }
          } catch (error) {
            console.error(`Error processing email file ${item.key}:`, error);
          }
        }
      }
    }
    
    return {
      success: true,
      data: emails.sort((a, b) => 
        new Date(b.receivedAt).getTime() - new Date(a.receivedAt).getTime()
      )
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to check S3 emails'
    };
  }
}

// ヘルパー関数
async function checkEmailAddressExists(address: string): Promise<boolean> {
  try {
    const { data } = await client.models.EmailAddress.list({
      filter: {
        address: { eq: address }
      }
    });
    
    return data && data.length > 0;
  } catch (error) {
    console.error('Error checking email address:', error);
    return false;
  }
}

function generateEmailAddress(): string {
  const now = new Date();
  const year = now.getFullYear().toString().slice(-2);
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  const sequence = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  
  return `${year}${month}${day}${sequence}@otm.mec.mejsh.com`;
}

function isEmailForAddress(emailContent: string, emailAddress: string): boolean {
  return emailContent.includes(`To: ${emailAddress}`) || 
         emailContent.includes(`<${emailAddress}>`);
}

function parseEmailContent(emailContent: string, s3Key: string): Email {
  const fromMatch = emailContent.match(/From:\s*(.+)/);
  const subjectMatch = emailContent.match(/Subject:\s*(.+)/);
  const bodyMatch = emailContent.match(/\n\n(.+)/s);
  
  return {
    id: generateId(),
    from: fromMatch ? fromMatch[1].trim() : 'Unknown',
    subject: subjectMatch ? subjectMatch[1].trim() : undefined,
    body: bodyMatch ? bodyMatch[1].trim() : emailContent,
    receivedAt: new Date().toISOString(),
    s3Key: s3Key
  };
}

function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}
```

### 6.2 Amplify設定ユーティリティ
```typescript
// utils/amplify-utils.ts
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';

// Amplify設定
Amplify.configure(outputs);

export { Amplify };
```

## 7. スタイリング設計

### 7.1 Tailwind CSS設定
```javascript
// tailwind.config.js
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          500: '#3b82f6',
          600: '#2563eb',
        },
      },
    },
  },
  plugins: [],
}
```

### 7.2 グローバルスタイル
```css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-family: system-ui, sans-serif;
  }
}

@layer components {
  .btn-primary {
    @apply px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors;
  }
  
  .btn-secondary {
    @apply px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors;
  }
  
  .input-field {
    @apply px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500;
  }
}
```

## 8. レスポンシブデザイン

### 8.1 ブレークポイント
- **モバイル**: 320px - 768px
- **タブレット**: 768px - 1024px
- **デスクトップ**: 1024px以上

### 8.2 レスポンシブ対応例
```typescript
// メール一覧のレスポンシブ対応
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {emails.map((email) => (
    <div key={email.id} className="p-4 border rounded-lg">
      {/* メール内容 */}
    </div>
  ))}
</div>
```

## 9. エラーハンドリング

### 9.1 エラー境界コンポーネント
```typescript
// components/ErrorBoundary.tsx
'use client';

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center">
          <div className="text-center">
            <h2 className="text-2xl font-bold text-red-600 mb-4">
              エラーが発生しました
            </h2>
            <p className="text-gray-600 mb-4">
              ページを再読み込みしてください
            </p>
            <button
              onClick={() => window.location.reload()}
              className="btn-primary"
            >
              再読み込み
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## 10. パフォーマンス最適化

### 10.1 メモ化
```typescript
import { memo, useMemo } from 'react';

// コンポーネントのメモ化
export const EmailItem = memo(({ email }: { email: Email }) => {
  // コンポーネント実装
});

// 計算のメモ化
const sortedEmails = useMemo(() => {
  return emails.sort((a, b) => 
    new Date(b.receivedAt).getTime() - new Date(a.receivedAt).getTime()
  );
}, [emails]);
```

### 10.2 遅延読み込み
```typescript
import { lazy, Suspense } from 'react';

const EmailViewer = lazy(() => import('./EmailViewer'));

// 使用例
<Suspense fallback={<LoadingSpinner />}>
  <EmailViewer email={selectedEmail} onClose={handleClose} />
</Suspense>
```

---

**作成日**: 2024年12月19日  
**バージョン**: 1.0  
**作成者**: AI Assistant
